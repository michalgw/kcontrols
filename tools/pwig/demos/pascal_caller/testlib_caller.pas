// ************************************************************************
// This file implements library imports for the caller.
// -------
// WARNING
// -------
// This file was generated by PWIG. Do not edit.
// File generated on 30.10.2016 18:10:05

unit testlib_caller;

{$IFDEF FPC}{$MODE DELPHI}{$ENDIF}

// Library properties:
// Name: TestLib
// Version: 1.0
// GUID: F3C093C0-035B-4C33-BB28-C1FDE270D3B5
// Description: Test library

interface

uses
  {$IFDEF FPC}
  DynLibs,
  {$ELSE}
  {$IFDEF MSWINDOWS}
  Windows,
  {$ENDIF}
  {$ENDIF}
  testlib_intf;

type

  // Forward declarations:
  TProjectGroup = class;
  TProject = class;

  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  TProjectGroupIProjectGroupEventsOnErrorEvent = procedure(const ErrorCode: TErrorCode; const ErrorText: AnsiString) of object;
  TProjectGroupIProjectGroupEventsOnProgressEvent = procedure(const EventCode: TProgressEvent; const ProgressValue: LongInt; const EventText: AnsiString) of object;

  TProjectGroup = class(TObject)
  private
    FOnError: TProjectGroupIProjectGroupEventsOnErrorEvent;
    FOnProgress: TProjectGroupIProjectGroupEventsOnProgressEvent;
    FItemHandle: IProjectGroup;
    // Property getters and setters:
  public
    constructor Create(AInterfaceHandle: IProjectGroup = 0);
    destructor Destroy; override;
    // Methods:
    function AddProject: IProject;
    procedure RunPeriodic;
    procedure Finalize;
    // Properties:
    // Events:
    property OnError: TProjectGroupIProjectGroupEventsOnErrorEvent read FOnError write FOnError;
    property OnProgress: TProjectGroupIProjectGroupEventsOnProgressEvent read FOnProgress write FOnProgress;
    // Default interface handle:
    property Handle: IProjectGroup read FItemHandle;
  end;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object


  TProject = class(TObject)
  private
    FItemHandle: IProject;
    // Property getters and setters:
    function GetConnectionFRC: LongInt;
    function GetConnectionString: AnsiString;
  public
    constructor Create(AInterfaceHandle: IProject = 0);
    destructor Destroy; override;
    // Methods:
    procedure Connect;
    procedure Disconnect;
    function LoadFromFile(const Path: AnsiString): TBool;
    function SaveToFile(const Path: AnsiString): TBool;
    // Properties:
    property ConnectionFRC: LongInt read GetConnectionFRC;
    property ConnectionString: AnsiString read GetConnectionString;
    // Default interface handle:
    property Handle: IProject read FItemHandle;
  end;

  function TestLibLibLoad(const FileName: string): Boolean;
  procedure TestLibLibUnload;
implementation

uses
  Math, SysUtils;

const
  LibModule: HMODULE = 0;
  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  // Constructor:
  FuncProjectGroupCreate: TProjectGroupCreate = nil;
  // Destructor:
  FuncProjectGroupDestroy: TProjectGroupDestroy = nil;
  // Methods:
  FuncProjectGroupIProjectGroupAddProject: TIProjectGroupAddProject = nil;
  FuncProjectGroupIProjectGroupRunPeriodic: TIProjectGroupRunPeriodic = nil;
  FuncProjectGroupIProjectGroupFinalize: TIProjectGroupFinalize = nil;
  // Properties:
  // Event handler setters:
  FuncSetProjectGroupIProjectGroupEventsOnError: TSetProjectGroupIProjectGroupEventsOnError = nil;
  FuncSetProjectGroupIProjectGroupEventsOnProgress: TSetProjectGroupIProjectGroupEventsOnProgress = nil;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object

  // Constructor:
  FuncProjectCreate: TProjectCreate = nil;
  // Destructor:
  FuncProjectDestroy: TProjectDestroy = nil;
  // Methods:
  FuncProjectIProjectConnect: TIProjectConnect = nil;
  FuncProjectIProjectDisconnect: TIProjectDisconnect = nil;
  FuncProjectIProjectLoadFromFile: TIProjectLoadFromFile = nil;
  FuncProjectIProjectSaveToFile: TIProjectSaveToFile = nil;
  // Properties:
  FuncProjectGetIProjectConnectionFRC: TGetIProjectConnectionFRC = nil;
  FuncProjectGetIProjectConnectionString: TGetIProjectConnectionString = nil;

procedure LibCallError(const AFuncName: string);
begin
  raise Exception.Create(Format('Error while calling library function %s!', [AFuncName]));
end;

procedure LibLoadError(const AFuncName: string);
begin
  raise Exception.Create(Format('Requested function %s does not exist in the library!', [AFuncName]));
end;

function TestLibLibLoad(const FileName: string): Boolean;
begin
  if LibModule = 0 then
    LibModule := LoadLibrary({$IFnDEF FPC}PChar{$ENDIF}(FileName));
  if LibModule <> 0 then
  begin
    // Name: ProjectGroup
    // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
    // Description: ProjectGroup Object

    // Constructor:
    FuncProjectGroupCreate := GetProcAddress(LibModule, 'ProjectGroupCreate');
    if not Assigned(FuncProjectGroupCreate) then LibLoadError('ProjectGroupCreate');
    // Destructor:
    FuncProjectGroupDestroy := GetProcAddress(LibModule, 'ProjectGroupDestroy');
    if not Assigned(FuncProjectGroupDestroy) then LibLoadError('ProjectGroupDestroy');
    // Methods:
    FuncProjectGroupIProjectGroupAddProject := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupAddProject');
    if not Assigned(FuncProjectGroupIProjectGroupAddProject) then LibLoadError('ProjectGroupIProjectGroupAddProject');
    FuncProjectGroupIProjectGroupRunPeriodic := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupRunPeriodic');
    if not Assigned(FuncProjectGroupIProjectGroupRunPeriodic) then LibLoadError('ProjectGroupIProjectGroupRunPeriodic');
    FuncProjectGroupIProjectGroupFinalize := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupFinalize');
    if not Assigned(FuncProjectGroupIProjectGroupFinalize) then LibLoadError('ProjectGroupIProjectGroupFinalize');
    // Properties:
    // Event handler setters:
    FuncSetProjectGroupIProjectGroupEventsOnError := GetProcAddress(LibModule, 'SetProjectGroupIProjectGroupEventsOnError');
    if not Assigned(FuncSetProjectGroupIProjectGroupEventsOnError) then LibLoadError('SetProjectGroupIProjectGroupEventsOnError');
    FuncSetProjectGroupIProjectGroupEventsOnProgress := GetProcAddress(LibModule, 'SetProjectGroupIProjectGroupEventsOnProgress');
    if not Assigned(FuncSetProjectGroupIProjectGroupEventsOnProgress) then LibLoadError('SetProjectGroupIProjectGroupEventsOnProgress');
    // Name: Project
    // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
    // Description: Project Object

    // Constructor:
    FuncProjectCreate := GetProcAddress(LibModule, 'ProjectCreate');
    if not Assigned(FuncProjectCreate) then LibLoadError('ProjectCreate');
    // Destructor:
    FuncProjectDestroy := GetProcAddress(LibModule, 'ProjectDestroy');
    if not Assigned(FuncProjectDestroy) then LibLoadError('ProjectDestroy');
    // Methods:
    FuncProjectIProjectConnect := GetProcAddress(LibModule, 'ProjectIProjectConnect');
    if not Assigned(FuncProjectIProjectConnect) then LibLoadError('ProjectIProjectConnect');
    FuncProjectIProjectDisconnect := GetProcAddress(LibModule, 'ProjectIProjectDisconnect');
    if not Assigned(FuncProjectIProjectDisconnect) then LibLoadError('ProjectIProjectDisconnect');
    FuncProjectIProjectLoadFromFile := GetProcAddress(LibModule, 'ProjectIProjectLoadFromFile');
    if not Assigned(FuncProjectIProjectLoadFromFile) then LibLoadError('ProjectIProjectLoadFromFile');
    FuncProjectIProjectSaveToFile := GetProcAddress(LibModule, 'ProjectIProjectSaveToFile');
    if not Assigned(FuncProjectIProjectSaveToFile) then LibLoadError('ProjectIProjectSaveToFile');
    // Properties:
    FuncProjectGetIProjectConnectionFRC := GetProcAddress(LibModule, 'ProjectGetIProjectConnectionFRC');
    if not Assigned(FuncProjectGetIProjectConnectionFRC) then LibLoadError('ProjectGetIProjectConnectionFRC');
    FuncProjectGetIProjectConnectionString := GetProcAddress(LibModule, 'ProjectGetIProjectConnectionString');
    if not Assigned(FuncProjectGetIProjectConnectionString) then LibLoadError('ProjectGetIProjectConnectionString');
  end;
  Result := LibModule <> 0;
end;

procedure TestLibLibUnload;
begin
  if LibModule <> 0 then
    FreeLibrary(LibModule);
  LibModule := 0;
  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  // Constructor:
  FuncProjectGroupCreate := nil;
  // Destructor:
  FuncProjectGroupDestroy := nil;
  // Methods:
  FuncProjectGroupIProjectGroupAddProject := nil;
  FuncProjectGroupIProjectGroupRunPeriodic := nil;
  FuncProjectGroupIProjectGroupFinalize := nil;
  // Properties:
  // Event handler setters:
  FuncSetProjectGroupIProjectGroupEventsOnError := nil;
  FuncSetProjectGroupIProjectGroupEventsOnProgress := nil;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object

  // Constructor:
  FuncProjectCreate := nil;
  // Destructor:
  FuncProjectDestroy := nil;
  // Methods:
  FuncProjectIProjectConnect := nil;
  FuncProjectIProjectDisconnect := nil;
  FuncProjectIProjectLoadFromFile := nil;
  FuncProjectIProjectSaveToFile := nil;
  // Properties:
  FuncProjectGetIProjectConnectionFRC := nil;
  FuncProjectGetIProjectConnectionString := nil;

end;

// Name: ProjectGroup
// GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
// Description: ProjectGroup Object

// Event handler callbacks:

function ProjectGroupIProjectGroupEventsOnError(const ItemHandle: IProjectGroupEvents; const ErrorCode: TErrorCode; const ErrorText: PAnsiChar): Boolean; cdecl;
begin
  Result := False;
  try
    if TObject(ItemHandle) is TProjectGroup then
    begin
      if Assigned(TProjectGroup(ItemHandle).OnError) then
      begin
        TProjectGroup(ItemHandle).OnError(ErrorCode, ErrorText);
      end;
      Result := True;
    end;
  except
  end;
end;


function ProjectGroupIProjectGroupEventsOnProgress(const ItemHandle: IProjectGroupEvents; const EventCode: TProgressEvent; const ProgressValue: LongInt; const EventText: PAnsiChar): Boolean; cdecl;
begin
  Result := False;
  try
    if TObject(ItemHandle) is TProjectGroup then
    begin
      if Assigned(TProjectGroup(ItemHandle).OnProgress) then
      begin
        TProjectGroup(ItemHandle).OnProgress(EventCode, ProgressValue, EventText);
      end;
      Result := True;
    end;
  except
  end;
end;

// Constructor:
constructor TProjectGroup.Create(AInterfaceHandle: IProjectGroup);
begin
  FItemHandle := AInterfaceHandle;
  if (FItemHandle = 0) and Assigned(FuncProjectGroupCreate) then
    FuncProjectGroupCreate(FItemHandle);
  FOnError := nil;
  if Assigned(FuncSetProjectGroupIProjectGroupEventsOnError) then
  begin
    if not (
      FuncSetProjectGroupIProjectGroupEventsOnError(FItemHandle, IProjectGroupEvents(Self), ProjectGroupIProjectGroupEventsOnError)
    ) then LibCallError('FuncSetProjectGroupIProjectGroupEventsOnError');
  end;
  FOnProgress := nil;
  if Assigned(FuncSetProjectGroupIProjectGroupEventsOnProgress) then
  begin
    if not (
      FuncSetProjectGroupIProjectGroupEventsOnProgress(FItemHandle, IProjectGroupEvents(Self), ProjectGroupIProjectGroupEventsOnProgress)
    ) then LibCallError('FuncSetProjectGroupIProjectGroupEventsOnProgress');
  end;
end;

// Destructor:
destructor TProjectGroup.Destroy;
begin
  if Assigned(FuncProjectGroupDestroy) then
    FuncProjectGroupDestroy(FItemHandle);
  inherited;
end;

// Methods:
function TProjectGroup.AddProject: IProject;
begin
  if Assigned(FuncProjectGroupIProjectGroupAddProject) then
  begin
    if not (
      FuncProjectGroupIProjectGroupAddProject(FItemHandle, Result)
    ) then LibCallError('FuncProjectGroupIProjectGroupAddProject');
  end;
end;

procedure TProjectGroup.RunPeriodic;
begin
  if Assigned(FuncProjectGroupIProjectGroupRunPeriodic) then
  begin
    if not (
      FuncProjectGroupIProjectGroupRunPeriodic(FItemHandle)
    ) then LibCallError('FuncProjectGroupIProjectGroupRunPeriodic');
  end;
end;

procedure TProjectGroup.Finalize;
begin
  if Assigned(FuncProjectGroupIProjectGroupFinalize) then
  begin
    if not (
      FuncProjectGroupIProjectGroupFinalize(FItemHandle)
    ) then LibCallError('FuncProjectGroupIProjectGroupFinalize');
  end;
end;

// Properties:

// Name: Project
// GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
// Description: Project Object

// Constructor:
constructor TProject.Create(AInterfaceHandle: IProject);
begin
  FItemHandle := AInterfaceHandle;
  if (FItemHandle = 0) and Assigned(FuncProjectCreate) then
    FuncProjectCreate(FItemHandle);
end;

// Destructor:
destructor TProject.Destroy;
begin
  if Assigned(FuncProjectDestroy) then
    FuncProjectDestroy(FItemHandle);
  inherited;
end;

// Methods:
procedure TProject.Connect;
begin
  if Assigned(FuncProjectIProjectConnect) then
  begin
    if not (
      FuncProjectIProjectConnect(FItemHandle)
    ) then LibCallError('FuncProjectIProjectConnect');
  end;
end;

procedure TProject.Disconnect;
begin
  if Assigned(FuncProjectIProjectDisconnect) then
  begin
    if not (
      FuncProjectIProjectDisconnect(FItemHandle)
    ) then LibCallError('FuncProjectIProjectDisconnect');
  end;
end;

function TProject.LoadFromFile(const Path: AnsiString): TBool;
begin
  if Assigned(FuncProjectIProjectLoadFromFile) then
  begin
    if not (
      FuncProjectIProjectLoadFromFile(FItemHandle, PAnsiChar(Path), Result)
    ) then LibCallError('FuncProjectIProjectLoadFromFile');
  end;
end;

function TProject.SaveToFile(const Path: AnsiString): TBool;
begin
  if Assigned(FuncProjectIProjectSaveToFile) then
  begin
    if not (
      FuncProjectIProjectSaveToFile(FItemHandle, PAnsiChar(Path), Result)
    ) then LibCallError('FuncProjectIProjectSaveToFile');
  end;
end;

// Properties:
function TProject.GetConnectionFRC: LongInt;
begin
  if Assigned(FuncProjectGetIProjectConnectionFRC) then
  begin
    if not (
      FuncProjectGetIProjectConnectionFRC(FItemHandle, Result)
    ) then LibCallError('FuncProjectGetIProjectConnectionFRC');
  end;
end;

function TProject.GetConnectionString: AnsiString;
var
  String__Value: AnsiString; Length__Value: LongInt;
begin
  if Assigned(FuncProjectGetIProjectConnectionString) then
  begin
    Length__Value := 0;
    if not (
      FuncProjectGetIProjectConnectionString(FItemHandle, nil, Length__Value)
    ) then LibCallError('FuncProjectGetIProjectConnectionString');
    SetLength(String__Value, Max(Length__Value, 1));
    if not (
      FuncProjectGetIProjectConnectionString(FItemHandle, PAnsiChar(String__Value), Length__Value)
    ) then LibCallError('FuncProjectGetIProjectConnectionString');
  end;
  if Length__Value > 0 then Result := String__Value else Result := '';
end;


end.
